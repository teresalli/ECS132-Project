---
title: "ECS 132 - Project"
author: Teresa Li, sqtli@ucdavis.edu \break Wenjing Fu, luffu@ucdavis.edu
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
\pagebreak[4]

# Design

## Question 1
```{r Q1}
Traffic_data_orig <- read.csv("Traffic_data_orig.csv", header=TRUE)
message <- "this is a secret message"
raw <- charToRaw(message)
time = Traffic_data_orig$Time
num = as.integer(rawToBits(raw))

delays = numeric(length(time) - 1)
for (i in (1:(length(time) - 1))) {
  delays[i] = time[i+1] - time[i]
}

index = 1
bitlen = length(raw)*8
encrpt <- numeric(length(raw)*8)
for (i in (0:(length(raw)-1))) {
  for (j in 1:8) {
    if (num[i*8+j] == 0) {
      encrpt[index] = 0.25
    }
    else {
      encrpt[index] = 0.75
    }
    index = index+1
    j = j-1
  }
}

delays2 = delays
for (i in (1:bitlen)) {
  delays2[i] = encrpt[i]
}
```


## Question 2
```{r Q2, dependson='Q1'}
hist(delays, col='grey', xlab = 'Delay Time', 
     main = 'Histogram of Overt Packet Stream')
hist(delays2, col='grey', xlab = 'Delay Time', 
     main = 'Histogram of Convert Packet Stream')
```
Yes, Eve will be suspicious because it is obvious that the distribution changed.

## Question 3

```{r Q3}
Traffic_data_orig <- read.csv("Traffic_data_orig.csv", header=TRUE)
message <- "this is a secret message"
raw <- charToRaw(message)
time = Traffic_data_orig$Time
num = as.integer(rawToBits(raw))
delays = numeric(length(time) - 1)
for (i in (1:(length(time) - 1))) {
  delays[i] = time[i+1] - time[i]
}
m = median(delays)
max = max(delays)
min = min(delays)

index = 1
bitlen = length(raw)*8
encrpt <- numeric(length(raw)*8)
for (i in (0:(length(raw)-1))) {
  for (j in 1:8) {
    if (num[i * 8 + j] == 0) {
      encrpt[index] = runif(1, min, m)
    }
    else {
      encrpt[index] = runif(1, m, max)
    }
    index = index + 1
    j = j - 1
  }
}

delays3 = delays
for (i in (1:bitlen)) {
  delays3[i] = encrpt[i]
}
```

## Question 4
```{r Q4, dependson='Q3'}
hist(delays, col='grey', xlab = 'Delay Time', 
     main = 'Histogram of Overt Packet Stream')
hist(delays2, col='grey', xlab = 'Delay Time', 
     main = 'Histogram of Convert Packet Stream')
```
I think Eva will not be suspicious.

## Question 5

1. Instead of generating random number from m to max, and min to m, we can choose one of the existing one from m to max, and min to m.

2. 

3. 

# Detection

## Step 1

```{r S1}
data1 <- rnorm(30)
data2 <- rnorm(30)
qqplot(data1, data2)
lines(data1, data1, type = 'l')
```

## Step 2

```{r S2}
data1 <- rnorm(100)
data2 <- rnorm(100)
qqplot(data1, data2)
lines(data1, data1, type = 'l')
data1 <- rnorm(1000)
data2 <- rnorm(1000)
qqplot(data1, data2)
lines(data1, data1, type = 'l')
```

Two plots are directly proportional to each other.

## Step 3

```{r S3}
data1 <- rnorm(100)
data2 <- rnorm(100, mean = 5, sd = 3)
qqplot(data1, data2)
lines(data1, data1, type = 'l')
```

data2 is directly proportional to data1, but the slope is different this time.

## Step 4

```{r S4}
data1 <- rexp(100)
data2 <- rexp(100)
qqplot(data1, data2)
lines(data1, data1, type = 'l')
data1 <- rexp(1000)
data2 <- rexp(1000)
qqplot(data1, data2)
lines(data1, data1, type = 'l')
```

With a bigger size, two data sets are more consistent.

## Step 5

```{r S5}
data1 <- rnorm(100)
data2 <- rexp(100)
qqplot(data1, data2)
lines(data1, data1, type = 'l')
data1 <- rnorm(500)
data2 <- rexp(500)
qqplot(data1, data2)
lines(data1, data1, type = 'l')
```

Their relation is exponential.

## Step 6

```{r S6, dependson='Q1'}
qqplot(delays, delays2)
lines(delays, delays, type = 'l')
```

## Step 7

```{r S7, dependson='Q3'}
qqplot(delays, delays3)
lines(delays, delays, type = 'l')
```

## Step 8

```{r S8}
Traffic_data_orig <- read.csv("Traffic_data_orig.csv", header=TRUE)
message <- "this is a secret message"
raw <- charToRaw(message)
time = Traffic_data_orig$Time
num = as.integer(rawToBits(raw))
delays = numeric(length(time) - 1)
for (i in (1:(length(time) - 1))) {
  delays[i] = time[i+1] - time[i]
}
m = median(delays)
max = max(delays)
min = min(delays)

index = 1
bitlen = length(raw)*8
encrpt <- numeric(length(raw)*8)
for (i in (0:(length(raw)-1))) {
  for (j in 1:8) {
    if (num[i * 8 + j] == 0) {
      encrpt[index] = sample(delays[which(delays >= min && delays <= m)])[1]
    }
    else {
      encrpt[index] = sample(delays[which(delays >= m && delays <= max)])[1]
    }
    index = index + 1
    j = j - 1
  }
}

delays4 = delays
for (i in (1:bitlen)) {
  delays4[i] = encrpt[i]
}
qqplot(delays, delays4)
lines(delays, delays, type = 'l')
```

# Implementation

## Implementation 1

```{r I1}
generateMessage <- function (len) {
  message <- numeric(len)
  for (i in (1:len)){
    message[i] = sample(c(0,1), 1)
  }
  return(message)
}

generateTime <- function(ipd, len) {
  time <- numeric(len)
  time[1] = 0
  for (i in (2:len)){
    time[i] = time[i-1] + ipd[i-1]
  }
  return(time)
}

#generateProb <- function () {
  bufferSize = 20
  ipd <- rexp(50)
  ipd2 <- rexp(50)
  ipdTime <- generateTime(ipd, 51)
  min = min(ipd)
  max = max(ipd)
  med = median(ipd)
  m <- c(16,32)
  bufferNum <- c(2,6,10,14,18)
  count = 0
  underflow = 0
  overflow = 0
  for (index in (1:2)) {
    len = m[index]
    message <- generateMessage(len) # generate a message
  
    for (j in (1:5)) {
      mi = 1
      i = bufferNum[j]
      bufferSize = bufferSize - i
      tempTime = ipdTime[i] # buffer i packets
      # modify and send it
      
      
      count = count + 1
    }
  }
  #return(c(underflow/count,overflow/count))
#}
#generateProb()
```
